#!/usr/bin/python

from pathlib import Path
import re
import os
from tqdm import tqdm
import argparse
from glob import escape
import requests
from iadownload.File import File
import hashlib
from enum import Enum


class SupportedFormats(Enum):
    FLAC = "flac"
    MP3 = "mp3"

    @classmethod
    def values(cls):
        return list(map(lambda f: f.value, cls))


def throw_error(message: str):
    print(message)
    exit(1)


def throw_with_cleanup(message: str, dir_to_remove):
    print(message)
    if os.path.exists(dir_to_remove) and not os.listdir(dir_to_remove):
        os.rmdir(dir_to_remove)
    exit(1)


def combine_list(items: list) -> str:
    return ", ".join(items) if hasattr(items, '__iter__') else items


def download_file(file: File, ext: str, output: str) -> bool:
    print(f"Downloading {file.ia_base_name}.{ext} as {file.get_base_name()}.{ext}")

    attempts = 0
    while attempts < 1:
        with requests.get(f"{file.url}.{ext}", stream=True) as dl:
            if dl.status_code == 200:
                total_size = int(dl.headers.get("content-length"))
                with open(f"{output}.{ext}", "wb") as out_file:
                    with tqdm(total=total_size, unit="B", unit_scale=True, initial=0, ascii=True) as progress:
                        for chunk in dl.iter_content(chunk_size=1024):
                            if chunk:
                                out_file.write(chunk)
                                progress.update(len(chunk))
                downloaded_md5 = hashlib.md5(open(output, "rb").read()).hexdigest()
                if file.md5 != downloaded_md5:
                    print(f"Downloaded file MD5 {downloaded_md5} does not match expected value {file.md5}"
                          f"{', retrying...' if attempts < 3 else ''}")
                    os.remove(output)
                    attempts += 1
                else:
                    return True
            else:
                print(f"Failed to download {file.ia_base_name}.{ext} as {file.get_base_name()}.{ext}"
                      f"{', retrying...' if attempts < 3 else ''}")
                attempts += 1
    print(f"Failed to download {file.ia_base_name}.{ext} as {file.get_base_name()}.{ext}")
    return False


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument("url", help="enter a URL to retrieve")
    parser.add_argument("-o", "--output", help="directory to download files to (default: current directory)")
    parser.add_argument("-f", "--format", help="format to save files as (default: flac)")
    parser.add_argument("-r", "--retry",
                        help="retry download as mp3 if download of specified format fails (default: false)",
                        action="store_true")

    args = parser.parse_args()
    url = args.url
    target_dir = escape(Path(args.output)) if args.output else escape(Path(os.getcwd()))
    format = SupportedFormats.MP3
    retry = args.retry

    if args.format in SupportedFormats.values():
        format = SupportedFormats(args.format)
    elif args.format is not None:
        throw_error("Invalid format specified")

    if not re.search("https?://archive.org/.*", url):
        throw_error("Invalid archive.org URL")

    if not os.path.exists(target_dir):
        throw_error("Output directory does not exist")

    page = requests.get(f"{url}?output=json").json()

    base_url = "https://" + page.get("server") + page.get("dir")

    metadata = page.get("metadata")

    artist = combine_list(metadata.get("creator"))
    location = combine_list(metadata.get("coverage"))
    venue = combine_list(metadata.get("venue"))
    date = combine_list(metadata.get("date"))

    output_dir = Path(f"{target_dir}/{date} - {artist} - {venue}, {location}")
    output_dir.mkdir(parents=True, exist_ok=True)
    print(f"Saving to {output_dir}")

    all_files = page.get("files")


    def get_base_names(file):
        return file[:file.rindex(".")] if "." in file else None


    base_ia_file_names = list(set([file for file in map(get_base_names, all_files) if file is not None]))
    base_ia_file_names.sort()

    files = []
    base_file_names = []
    for file in base_ia_file_names:
        supported_exts = []
        for ext in SupportedFormats.values():
            if f"{file}.{ext}" in all_files:
                supported_exts.append(ext)
        if supported_exts:
            files.append(File(base_url + file, all_files[f"{file}.{supported_exts[0]}"], supported_exts))
            base_file_names.append(file)

    for file in files:
        if not file.track_num:
            file.track_num = base_file_names.index(file.ia_base_name) + 1

    if files:
        for file in files:
            if format.value in file.supported_extensions:
                if not download_file(file, format.value, f"{output_dir}/{file.get_base_name()}"):
                    if (SupportedFormats.FLAC == format and retry
                            and SupportedFormats.MP3.value in file.supported_extensions):
                        print(f"Falling back to MP3 for file {file.get_base_name()}")
                        if not (download_file(file, SupportedFormats.MP3.value,
                                              f"{output_dir}/{file.get_base_name()}")):
                            print(
                                f"Failed to download file {file.get_base_name()}"
                                f" as {SupportedFormats.MP3.value}")
                    else:
                        print(f"Failed to download file {file.get_base_name()}.{format.value}")
            else:
                if retry and SupportedFormats.MP3.value in file.supported_extensions:
                    print(f"Falling back to MP3 for file {file.get_base_name()}")
                    if not (download_file(file, SupportedFormats.MP3.value,
                                          f"{output_dir}/{file.get_base_name()}")):
                        print(
                            f"Failed to download file {file.get_base_name()}"
                            f"as {SupportedFormats.MP3.value}")
                else:
                    print(f"Failed to download file {file.get_base_name()}.{format.value}")
    else:
        throw_with_cleanup(f"No files in {format} format found!", output_dir)

    if os.path.exists(output_dir) and not os.listdir(output_dir):
        if files:
            throw_with_cleanup("Failed to download all files!", output_dir)
        os.rmdir(output_dir)
